from primitives.primitives import Permutation
from operators.Sbox import AES_Sbox
from operators.boolean_operators import XOR
from operators.AESround import AESround
import variables.variables as var

#  The Rocca_AD internal permutation  
class Rocca_AD_permutation(Permutation):
    def __init__(self, name, s_input, s_output, nbr_rounds=None, represent_mode=0):
        """
        Initialize the Rocca_AD internal permutation
        :param name: Name of the permutation
        :param version: Bit size of the permutation
        :param s_input: Input state
        :param s_output: Output state
        :param nbr_rounds: Number of rounds
        :param represent_mode: Integer specifying the mode of representation used for encoding the permutation.
        """
        
        if nbr_rounds==None: nbr_rounds=20
        if represent_mode==0: 
            nbr_layers, nbr_words, nbr_temp_words, word_bitsize = (4, 128+32*nbr_rounds, 32, 8)
            perm_s = [0,5,10,15, 4,9,14,3, 8,13,2,7, 12,1,6,11]
        elif represent_mode==1:
            nbr_layers, nbr_words, nbr_temp_words, word_bitsize = (2, 16*8+32*nbr_rounds, 32, 8)
        super().__init__(name, s_input, s_output, nbr_rounds, [nbr_layers, nbr_words, nbr_temp_words, word_bitsize])

        S = self.functions["PERMUTATION"]

        # create constraints
        if represent_mode==0:
            for r in range(1, nbr_rounds+1):
                S.PermutationLayer("P", r, 0, [i for i in range(16*7,16*8)] + perm_s + [i for i in range(16,16*2)] + [perm_s[i]+16*2 for i in range(16)] + [i for i in range(16*3,16*4)] + [perm_s[i]+16*4 for i in range(16)] + [perm_s[i]+16*5 for i in range(16)] + [i for i in range(16*6, 16*7)] + [i for i in range(16*8,16*(8+2*nbr_rounds))] + [i for i in range(16)] + [i for i in range(16*4, 16*5)])
                S.SboxLayer("SB", r, 1, AES_Sbox, mask=[0 for i in range(16)]+[1 for i in range(16)]+[0 for i in range(16)]+[1 for i in range(16)]+[0 for i in range(16)]+[1 for i in range(16)]+[1 for i in range(16)]) # Sbox layer 
                S.MatrixLayer("MC", r, 2, [[2,3,1,1], [1,2,3,1], [1,1,2,3], [3,1,1,2]], [[0+16,1+16,2+16,3+16], [4+16,5+16,6+16,7+16], [8+16,9+16,10+16,11+16], [12+16,13+16,14+16,15+16],[0+16*3,1+16*3,2+16*3,3+16*3], [4+16*3,5+16*3,6+16*3,7+16*3], [8+16*3,9+16*3,10+16*3,11+16*3], [12+16*3,13+16*3,14+16*3,15+16*3],[0+16*5,1+16*5,2+16*5,3+16*5], [4+16*5,5+16*5,6+16*5,7+16*5], [8+16*5,9+16*5,10+16*5,11+16*5], [12+16*5,13+16*5,14+16*5,15+16*5], [0+16*6,1+16*6,2+16*6,3+16*6], [4+16*6,5+16*6,6+16*6,7+16*6], [8+16*6,9+16*6,10+16*6,11+16*6], [12+16*6,13+16*6,14+16*6,15+16*6]], "0x1B")  #Mixcolumns layer
                S.SingleOperatorLayer("XOR", r, 3, XOR, [[i, i+16*(8+2*(r-1))] for i in range(16)] + [[i+16, i] for i in range(16)] + [[i+16*2, i+16*7] for i in range(16)] + [[i+16*3, i+16*2] for i in range(16)] + [[i+16*4, i+16*(8+2*(r-1)+1)] for i in range(16)] + [[i+16*5, i+16*4]  for i in range(16)] + [[i+16*6, i+16*(8+2*nbr_rounds+1)] for i in range(16)] + [[i+16*7, i+16*(8+2*nbr_rounds)] for i in range(16)],[i for i in range(16*8)]) # XOR layer 
        
        elif represent_mode==1:
            for r in range(1, nbr_rounds+1):
                S.SingleOperatorLayer("AES_r", r, 0, AESround, [[i for i in range(16)]] + [[i for i in range(16*2, 16*3)]] + [[i for i in range(16*4, 16*5)]] + [[i for i in range(16*5, 16*6)]], [[i for i in range(nbr_words, nbr_words+16)]] + [[i for i in range(16*2, 16*3)]] + [[i for i in range(nbr_words+16, nbr_words+16*2)]] + [[i for i in range(16*5, 16*6)]]) # XOR layer 
                S.SingleOperatorLayer("XOR", r, 1, XOR, [[i+7*16, i+16*(8+2*(r-1))] for i in range(16)] + [[i+nbr_words, i+16*7] for i in range(16)] + [[i+16*1, i+16*6] for i in range(16)] + [[i+16*2, i+16*1] for i in range(16)] + [[i+16*3, i+16*(8+2*(r-1)+1)] for i in range(16)] + [[i+nbr_words+16, i+16*3]  for i in range(16)] + [[i+16*5, i+16*4] for i in range(16)] + [[i, i+16*6] for i in range(16)],[i for i in range(16*8)]) # XOR layer 
        
    def gen_test_vectors(self):
        IN = [0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf]
        OUT = [0x63, 0x7a, 0x14, 0x3b, 0xd8, 0x28, 0xcb, 0xf3, 0x50, 0x46, 0xd5, 0x42, 0x48, 0xf6, 0x16, 0x7a, 0x36, 0xa8, 0x5, 0x69, 0x3b, 0x4b, 0x5a, 0x7, 0xd1, 0xa0, 0xe3, 0xcd, 0xa3, 0x10, 0x86, 0xda, 0x44, 0x76, 0x8c, 0xc0, 0xd3, 0x82, 0x5a, 0x59, 0xdc, 0xe1, 0x12, 0x76, 0x6b, 0x81, 0x68, 0x4e, 0xb8, 0x10, 0x59, 0x64, 0xe7, 0x89, 0xd4, 0x6b, 0x21, 0x43, 0x53, 0x1c, 0x20, 0x1a, 0x42, 0x85, 0x26, 0x81, 0x8f, 0xe9, 0x75, 0x3e, 0xdc, 0x29, 0xeb, 0xba, 0xc1, 0xe8, 0x22, 0x7c, 0xbc, 0x9c, 0x4c, 0xea, 0xd1, 0xaf, 0x5d, 0x56, 0xe9, 0x7f, 0x53, 0x6a, 0x96, 0x82, 0x9, 0xed, 0x93, 0xcf, 0x1, 0xf9, 0x2f, 0xd9, 0x7e, 0xc6, 0x3f, 0xfc, 0xcd, 0x54, 0x4e, 0x1, 0x5f, 0xad, 0x77, 0x2e, 0x2, 0x93, 0xf6, 0x21, 0xf9, 0xee, 0x4b, 0xd9, 0xe3, 0xa7, 0xdd, 0x62, 0xce, 0xf5, 0x1f, 0xa, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf]
        self.test_vectors.append([[IN], OUT])
    

def ROCCA_AD_PERMUTATION(r=5, represent_mode=0, copy_operator=False):
    my_input, my_output = [var.Variable(8,ID="in"+str(i)) for i in range(128+32*r)], [var.Variable(8,ID="out"+str(i)) for i in range(128+32*r)]
    my_permutation = Rocca_AD_permutation("ROCCA_AD", my_input, my_output, nbr_rounds=r, represent_mode=represent_mode)
    my_permutation.gen_test_vectors()
    my_permutation.post_initialization(copy_operator=copy_operator)
    return my_permutation